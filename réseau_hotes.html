<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Gestion R√©seaux, Sous-R√©seaux & H√¥tes</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    label, input, select { display: block; margin-bottom: 10px; }
    #message { margin-top: 15px; font-weight: bold; }
    .success { color: green; }
    .error { color: red; }
    .network, .subnet, .host {
      margin-top: 10px; padding: 10px;
      border: 1px solid #ccc; border-radius: 6px;
    }
    .subnet { margin-left: 20px; background-color: #f9f9f9; }
    .host { margin-left: 40px; background-color: #efefef; }
    button.action { margin-left: 10px; }
  </style>
</head>
<body>

<h2>Ajouter un r√©seau principal</h2>
<form id="formR√©seau">
  <input type="text" id="ip" placeholder="IP r√©seau (ex: 192.168.0.0)">
  <input type="number" id="cidr" placeholder="Masque CIDR (ex: 24)" min="1" max="32">
  <button type="submit">Ajouter</button>
</form>

<h2 id="message"></h2>
<div id="listeReseaux"></div>

<script>
  const reseaux = [];

  const estIPValide = (ip) => {
    const octets = ip.split(".");
    return (
      octets.length === 4 &&
      octets.every(o => /^\d+$/.test(o) && parseInt(o) >= 0 && parseInt(o) <= 255)
    );
  };

  const ipToInt = (ip) => ip.split('.').reduce((acc, octet) => (acc << 8) + parseInt(octet), 0) >>> 0;
  const intToIp = (int) => [(int >>> 24) & 255, (int >>> 16) & 255, (int >>> 8) & 255, int & 255].join('.');
  const calcNet = (ip, cidr) => intToIp(ipToInt(ip) & (~((1 << (32 - cidr)) - 1) >>> 0));
  const calcBroadcast = (ip, cidr) => intToIp(ipToInt(ip) | ((1 << (32 - cidr)) - 1));

  const message = (msg, success = true) => {
    const m = document.getElementById("message");
    m.textContent = msg;
    m.className = success ? "success" : "error";
  };

  const afficherListe = () => {
    const liste = document.getElementById("listeReseaux");
    liste.innerHTML = "";
    reseaux.forEach((r, i) => {
      const netDiv = document.createElement("div");
      netDiv.className = "network";
      netDiv.innerHTML = `<strong>${r.ip}/${r.cidr}</strong>
        <button class="action" onclick="supprimerReseau(${i})">üóëÔ∏è</button>
        <button class="action" onclick="modifierReseau(${i})">‚úèÔ∏è</button>
        <br><input placeholder='Sous-r√©seau IP' id='sousIp${i}'>
        <input type='number' placeholder='CIDR' min='1' max='32' id='sousCidr${i}'>
        <button onclick='ajouterSousReseau(${i})'>Ajouter Sous-r√©seau</button>
        <br><input placeholder='IP h√¥te' id='ipHoteDirect${i}'>
        <input placeholder='Nom h√¥te' id='nomHoteDirect${i}'>
        <button onclick='ajouterHoteDirect(${i})'>Ajouter H√¥te (direct)</button>`;

      r.hosts?.forEach((h, k) => {
        const hostDiv = document.createElement("div");
        hostDiv.className = "host";
        hostDiv.innerHTML = `${h.ip} - ${h.nom}
          <button class="action" onclick="supprimerHoteDirect(${i},${k})">üóëÔ∏è</button>
          <button class="action" onclick="modifierHoteDirect(${i},${k})">‚úèÔ∏è</button>`;
        netDiv.appendChild(hostDiv);
      });

      r.subnets.forEach((s, j) => {
        const subDiv = document.createElement("div");
        subDiv.className = "subnet";
        subDiv.innerHTML = `<strong>${s.ip}/${s.cidr}</strong>
          <button class="action" onclick="supprimerSousReseau(${i},${j})">üóëÔ∏è</button>
          <button class="action" onclick="modifierSousReseau(${i},${j})">‚úèÔ∏è</button>
          <br><input placeholder='IP h√¥te' id='ipHote${i}_${j}'>
          <input placeholder='Nom h√¥te' id='nomHote${i}_${j}'>
          <button onclick='ajouterHote(${i},${j})'>Ajouter H√¥te</button>`;

        s.hosts.forEach((h, k) => {
          const hostDiv = document.createElement("div");
          hostDiv.className = "host";
          hostDiv.innerHTML = `${h.ip} - ${h.nom}
            <button class="action" onclick="supprimerHote(${i},${j},${k})">üóëÔ∏è</button>
            <button class="action" onclick="modifierHote(${i},${j},${k})">‚úèÔ∏è</button>`;
          subDiv.appendChild(hostDiv);
        });

        netDiv.appendChild(subDiv);
      });

      liste.appendChild(netDiv);
    });
  };

  document.getElementById("formR√©seau").addEventListener("submit", e => {
    e.preventDefault();
    const ip = document.getElementById("ip").value.trim();
    const cidr = parseInt(document.getElementById("cidr").value);
    if (!estIPValide(ip) || isNaN(cidr)) return message("IP ou CIDR invalide", false);
    const netIp = calcNet(ip, cidr);
    if (ip !== netIp) return message("L'IP ne correspond pas au r√©seau pour ce CIDR", false);
    if (reseaux.some(r => r.ip === ip && r.cidr === cidr)) return message("R√©seau d√©j√† existant", false);
    reseaux.push({ ip, cidr, subnets: [], hosts: [] });
    message("R√©seau ajout√©");
    afficherListe();
    e.target.reset();
  });

  const ajouterSousReseau = (i) => {
    const ip = document.getElementById(`sousIp${i}`).value.trim();
    const cidr = parseInt(document.getElementById(`sousCidr${i}`).value);
    if (!estIPValide(ip) || isNaN(cidr)) return message("Sous-r√©seau invalide", false);
    const netIp = calcNet(ip, cidr);
    if (ip !== netIp) return message("L'IP ne correspond pas √† une adresse de sous-r√©seau pour ce CIDR", false);
    const parent = reseaux[i];
    const parentStart = ipToInt(parent.ip);
    const parentEnd = parentStart + (1 << (32 - parent.cidr)) - 1;
    const subnetStart = ipToInt(ip);
    const subnetEnd = subnetStart + (1 << (32 - cidr)) - 1;

    if (subnetStart < parentStart || subnetEnd > parentEnd)
      return message("Sous-r√©seau hors du r√©seau parent", false);

    if (parent.subnets.some(s => s.ip === ip && s.cidr === cidr))
      return message("Sous-r√©seau d√©j√† existant", false);

    parent.subnets.push({ ip, cidr, hosts: [] });
    message("Sous-r√©seau ajout√©");
    afficherListe();
  };

  const ajouterHoteDirect = (i) => {
    const ip = document.getElementById(`ipHoteDirect${i}`).value.trim();
    const nom = document.getElementById(`nomHoteDirect${i}`).value.trim();
    const net = reseaux[i];
    if (!estIPValide(ip) || !nom) return message("IP ou nom invalide", false);

    const ipInt = ipToInt(ip);
    const start = ipToInt(net.ip);
    const end = start + (1 << (32 - net.cidr)) - 1;
    const broadcast = ipToInt(calcBroadcast(net.ip, net.cidr));

    // V√©rifier si l'IP est dans le r√©seau
    if (ipInt <= start || ipInt >= end) return message("IP hors plage", false);

    // V√©rifier si l'IP est d√©j√† utilis√©e
    if (net.hosts.some(h => h.ip === ip)) return message("IP d√©j√† utilis√©e", false);
    for (const s of net.subnets) {
        if (s.hosts.some(h => h.ip === ip)) return message("IP d√©j√† utilis√©e dans un sous-r√©seau", false);
    }

    // V√©rifier si l'IP n'est pas une adresse r√©seau, sous-r√©seau ou broadcast existante
    if (ip === net.ip || ipInt === broadcast || net.subnets.some(s => ip === s.ip || ipInt === ipToInt(calcBroadcast(s.ip, s.cidr)))) return message("IP correspond √† une adresse r√©seau, sous-r√©seau ou broadcast", false);

    for (const s of net.subnets) {
        const subStart = ipToInt(s.ip);
        const subEnd = subStart + (1 << (32 - s.cidr)) - 1;
        const subBroadcast = ipToInt(calcBroadcast(s.ip, s.cidr));
        if (ipInt > subStart && ipInt < subEnd && ipInt !== subBroadcast) {
            s.hosts.push({ ip, nom });
            afficherListe();
            return message("H√¥te ajout√© dans le sous-r√©seau");
        }
    }

    net.hosts.push({ ip, nom });
    afficherListe();
    message("H√¥te ajout√© au r√©seau");
};

const modifierHoteDirect = (i, k) => {
    const net = reseaux[i];
    const hote = net.hosts[k];
    const nvIp = prompt("Nouvelle IP:", hote.ip);
    const nvNom = prompt("Nouveau nom:", hote.nom);
    if (!estIPValide(nvIp) || !nvNom) return message("Valeurs invalides", false);

    const ipInt = ipToInt(nvIp);
    const start = ipToInt(net.ip);
    const end = start + (1 << (32 - net.cidr)) - 1;
    const broadcast = ipToInt(calcBroadcast(net.ip, net.cidr));

    // V√©rifier si l'IP est dans le r√©seau
    if (ipInt <= start || ipInt >= end) return message("IP hors plage", false);

    // V√©rifier si l'IP est d√©j√† utilis√©e
    if (net.hosts.some((h, idx) => h.ip === nvIp && idx !== k)) return message("IP d√©j√† utilis√©e", false);
    for (const s of net.subnets) {
        if (s.hosts.some(h => h.ip === nvIp)) return message("IP d√©j√† utilis√©e dans un sous-r√©seau", false);
    }

    // V√©rifier si l'IP n'est pas une adresse r√©seau, sous-r√©seau ou broadcast existante
    if (nvIp === net.ip || ipInt === broadcast || net.subnets.some(s => nvIp === s.ip || ipInt === ipToInt(calcBroadcast(s.ip, s.cidr)))) return message("IP correspond √† une adresse r√©seau, sous-r√©seau ou broadcast", false);

    // D√©placer l'h√¥te si n√©cessaire
    net.hosts.splice(k, 1);
    for (const s of net.subnets) {
        const subStart = ipToInt(s.ip);
        const subEnd = subStart + (1 << (32 - s.cidr)) - 1;
        const subBroadcast = ipToInt(calcBroadcast(s.ip, s.cidr));
        if (ipInt > subStart && ipInt < subEnd && ipInt !== subBroadcast) {
            s.hosts.push({ ip: nvIp, nom: nvNom });
            afficherListe();
            return message("H√¥te d√©plac√© vers le sous-r√©seau");
        }
    }

    net.hosts.push({ ip: nvIp, nom: nvNom });
    afficherListe();
    message("H√¥te modifi√©");
};

  const supprimerHoteDirect = (i, k) => {
    reseaux[i].hosts.splice(k, 1);
    afficherListe();
  };

  const ajouterHote = (i, j) => {
    const ip = document.getElementById(`ipHote${i}_${j}`).value.trim();
    const nom = document.getElementById(`nomHote${i}_${j}`).value.trim();
    if (!estIPValide(ip) || !nom) return message("Valeurs invalides", false);

    const subnet = reseaux[i].subnets[j];
    const ipInt = ipToInt(ip);
    const subStart = ipToInt(subnet.ip);
    const subEnd = subStart + (1 << (32 - subnet.cidr)) - 1;
    const subBroadcast = ipToInt(calcBroadcast(subnet.ip, subnet.cidr));

    // V√©rifier si l'IP est dans le sous-r√©seau
    if (ipInt <= subStart || ipInt >= subEnd || ipInt === subBroadcast) return message("IP hors plage ou broadcast", false);

    // V√©rifier si l'IP est d√©j√† utilis√©e
    if (subnet.hosts.some(h => h.ip === ip)) return message("IP d√©j√† utilis√©e", false);

    // V√©rifier si l'IP n'est pas une adresse r√©seau, sous-r√©seau ou broadcast existante
    if (ip === subnet.ip || ipInt === subBroadcast || reseaux[i].subnets.some(s => ip === s.ip || ipInt === ipToInt(calcBroadcast(s.ip, s.cidr)))) return message("IP correspond √† une adresse r√©seau, sous-r√©seau ou broadcast", false);

    subnet.hosts.push({ ip, nom });
    afficherListe();
    message("H√¥te ajout√©");
};

const modifierHote = (i, j, k) => {
    const subnet = reseaux[i].subnets[j];
    const hote = subnet.hosts[k];
    const nvIp = prompt("Nouvelle IP:", hote.ip);
    const nvNom = prompt("Nouveau nom:", hote.nom);
    if (!estIPValide(nvIp) || !nvNom) return message("Valeurs invalides", false);

    const ipInt = ipToInt(nvIp);
    const subStart = ipToInt(subnet.ip);
    const subEnd = subStart + (1 << (32 - subnet.cidr)) - 1;
    const subBroadcast = ipToInt(calcBroadcast(subnet.ip, subnet.cidr));

    // V√©rifier si l'IP est dans le sous-r√©seau
    if (ipInt <= subStart || ipInt >= subEnd || ipInt === subBroadcast) return message("IP hors plage ou broadcast", false);

    // V√©rifier si l'IP est d√©j√† utilis√©e
    if (subnet.hosts.some((h, idx) => h.ip === nvIp && idx !== k)) return message("IP d√©j√† utilis√©e", false);

    // V√©rifier si l'IP n'est pas une adresse r√©seau, sous-r√©seau ou broadcast existante
    if (nvIp === subnet.ip || reseaux[i].subnets.some(s => nvIp === s.ip || ipInt === ipToInt(calcBroadcast(s.ip, s.cidr)))) return message("IP correspond √† une adresse r√©seau, sous-r√©seau ou broadcast", false);

    // Mettre √† jour l'h√¥te
    hote.ip = nvIp;
    hote.nom = nvNom;
    afficherListe();
    message("H√¥te modifi√©");
};

  const supprimerHote = (i, j, k) => {
    reseaux[i].subnets[j].hosts.splice(k, 1);
    afficherListe();
  };

  const modifierReseau = (i) => {
    const r = reseaux[i];
    const ip = prompt("Nouvelle IP r√©seau:", r.ip);
    const cidr = parseInt(prompt("Nouveau CIDR:", r.cidr));
    if (!estIPValide(ip) || isNaN(cidr)) return message("Invalide", false);
    if (calcNet(ip, cidr) !== ip) return message("L'IP ne correspond pas √† une adresse r√©seau", false);
    reseaux[i].ip = ip;
    reseaux[i].cidr = cidr;
    afficherListe();
  };

  const supprimerReseau = (i) => {
    reseaux.splice(i, 1);
    afficherListe();
  };

  const modifierSousReseau = (i, j) => {
    const s = reseaux[i].subnets[j];
    const ip = prompt("Nouvelle IP:", s.ip);
    const cidr = parseInt(prompt("Nouveau CIDR:", s.cidr));
    if (!estIPValide(ip) || isNaN(cidr)) return message("Invalide", false);
    if (calcNet(ip, cidr) !== ip) return message("L'IP ne correspond pas √† une adresse r√©seau", false);
    reseaux[i].subnets[j].ip = ip;
    reseaux[i].subnets[j].cidr = cidr;
    afficherListe();
  };

  const supprimerSousReseau = (i, j) => {
    reseaux[i].subnets.splice(j, 1);
    afficherListe();
  };
</script>

</body>
</html>